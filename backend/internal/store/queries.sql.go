// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package store

import (
	"context"
	"database/sql"
	"strings"
)

const checkSchemaExists = `-- name: CheckSchemaExists :one
SELECT COUNT(*) AS count FROM sections
`

func (q *Queries) CheckSchemaExists(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, checkSchemaExists)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const courseExistsAnyTerm = `-- name: CourseExistsAnyTerm :one
SELECT EXISTS(
    SELECT 1 FROM sections
    WHERE subject = ? AND course_number = ?
) AS course_exists
`

type CourseExistsAnyTermParams struct {
	Subject      string `json:"subject"`
	CourseNumber string `json:"course_number"`
}

func (q *Queries) CourseExistsAnyTerm(ctx context.Context, arg CourseExistsAnyTermParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, courseExistsAnyTerm, arg.Subject, arg.CourseNumber)
	var course_exists int64
	err := row.Scan(&course_exists)
	return course_exists, err
}

const deleteInstructorsBySection = `-- name: DeleteInstructorsBySection :exec
DELETE FROM instructors WHERE section_id = ?
`

func (q *Queries) DeleteInstructorsBySection(ctx context.Context, sectionID int64) error {
	_, err := q.db.ExecContext(ctx, deleteInstructorsBySection, sectionID)
	return err
}

const deleteMeetingTimesBySection = `-- name: DeleteMeetingTimesBySection :exec
DELETE FROM meeting_times WHERE section_id = ?
`

func (q *Queries) DeleteMeetingTimesBySection(ctx context.Context, sectionID int64) error {
	_, err := q.db.ExecContext(ctx, deleteMeetingTimesBySection, sectionID)
	return err
}

const deleteSectionAttributesBySection = `-- name: DeleteSectionAttributesBySection :exec
DELETE FROM section_attributes WHERE section_id = ?
`

func (q *Queries) DeleteSectionAttributesBySection(ctx context.Context, sectionID int64) error {
	_, err := q.db.ExecContext(ctx, deleteSectionAttributesBySection, sectionID)
	return err
}

const deleteSectionsByTerm = `-- name: DeleteSectionsByTerm :exec
DELETE FROM sections WHERE term = ?
`

func (q *Queries) DeleteSectionsByTerm(ctx context.Context, term string) error {
	_, err := q.db.ExecContext(ctx, deleteSectionsByTerm, term)
	return err
}

const getActiveAnnouncement = `-- name: GetActiveAnnouncement :one
SELECT id, title, body, type FROM announcements
WHERE active = 1 ORDER BY id DESC LIMIT 1
`

type GetActiveAnnouncementRow struct {
	ID    int64  `json:"id"`
	Title string `json:"title"`
	Body  string `json:"body"`
	Type  string `json:"type"`
}

func (q *Queries) GetActiveAnnouncement(ctx context.Context) (*GetActiveAnnouncementRow, error) {
	row := q.db.QueryRowContext(ctx, getActiveAnnouncement)
	var i GetActiveAnnouncementRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Body,
		&i.Type,
	)
	return &i, err
}

const getDistinctSubjects = `-- name: GetDistinctSubjects :many
SELECT DISTINCT subject FROM sections ORDER BY subject
`

func (q *Queries) GetDistinctSubjects(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getDistinctSubjects)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var subject string
		if err := rows.Scan(&subject); err != nil {
			return nil, err
		}
		items = append(items, subject)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDistinctSubjectsByTerm = `-- name: GetDistinctSubjectsByTerm :many
SELECT DISTINCT subject FROM sections WHERE term = ? ORDER BY subject
`

func (q *Queries) GetDistinctSubjectsByTerm(ctx context.Context, term string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getDistinctSubjectsByTerm, term)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var subject string
		if err := rows.Scan(&subject); err != nil {
			return nil, err
		}
		items = append(items, subject)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDistinctTerms = `-- name: GetDistinctTerms :many
SELECT DISTINCT term FROM sections ORDER BY term DESC
`

func (q *Queries) GetDistinctTerms(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getDistinctTerms)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var term string
		if err := rows.Scan(&term); err != nil {
			return nil, err
		}
		items = append(items, term)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInstructorsBySection = `-- name: GetInstructorsBySection :many
SELECT id, section_id, banner_id, name, email, is_primary FROM instructors WHERE section_id = ?
`

func (q *Queries) GetInstructorsBySection(ctx context.Context, sectionID int64) ([]*Instructor, error) {
	rows, err := q.db.QueryContext(ctx, getInstructorsBySection, sectionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Instructor{}
	for rows.Next() {
		var i Instructor
		if err := rows.Scan(
			&i.ID,
			&i.SectionID,
			&i.BannerID,
			&i.Name,
			&i.Email,
			&i.IsPrimary,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMeetingTimesBySection = `-- name: GetMeetingTimesBySection :many
SELECT id, section_id, start_time, end_time, start_date, end_date, building, building_description, room, monday, tuesday, wednesday, thursday, friday, saturday, sunday, schedule_type, meeting_type, credit_hours, hours_per_week FROM meeting_times WHERE section_id = ?
`

func (q *Queries) GetMeetingTimesBySection(ctx context.Context, sectionID int64) ([]*MeetingTime, error) {
	rows, err := q.db.QueryContext(ctx, getMeetingTimesBySection, sectionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*MeetingTime{}
	for rows.Next() {
		var i MeetingTime
		if err := rows.Scan(
			&i.ID,
			&i.SectionID,
			&i.StartTime,
			&i.EndTime,
			&i.StartDate,
			&i.EndDate,
			&i.Building,
			&i.BuildingDescription,
			&i.Room,
			&i.Monday,
			&i.Tuesday,
			&i.Wednesday,
			&i.Thursday,
			&i.Friday,
			&i.Saturday,
			&i.Sunday,
			&i.ScheduleType,
			&i.MeetingType,
			&i.CreditHours,
			&i.HoursPerWeek,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMeetingTimesBySectionIDs = `-- name: GetMeetingTimesBySectionIDs :many
SELECT
    section_id, start_time, end_time, building, room,
    sunday, monday, tuesday, wednesday, thursday, friday, saturday
FROM meeting_times
WHERE section_id IN (/*SLICE:section_ids*/?)
ORDER BY section_id
`

type GetMeetingTimesBySectionIDsRow struct {
	SectionID int64          `json:"section_id"`
	StartTime sql.NullString `json:"start_time"`
	EndTime   sql.NullString `json:"end_time"`
	Building  sql.NullString `json:"building"`
	Room      sql.NullString `json:"room"`
	Sunday    sql.NullInt64  `json:"sunday"`
	Monday    sql.NullInt64  `json:"monday"`
	Tuesday   sql.NullInt64  `json:"tuesday"`
	Wednesday sql.NullInt64  `json:"wednesday"`
	Thursday  sql.NullInt64  `json:"thursday"`
	Friday    sql.NullInt64  `json:"friday"`
	Saturday  sql.NullInt64  `json:"saturday"`
}

func (q *Queries) GetMeetingTimesBySectionIDs(ctx context.Context, sectionIds []int64) ([]*GetMeetingTimesBySectionIDsRow, error) {
	query := getMeetingTimesBySectionIDs
	var queryParams []interface{}
	if len(sectionIds) > 0 {
		for _, v := range sectionIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:section_ids*/?", strings.Repeat(",?", len(sectionIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:section_ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetMeetingTimesBySectionIDsRow{}
	for rows.Next() {
		var i GetMeetingTimesBySectionIDsRow
		if err := rows.Scan(
			&i.SectionID,
			&i.StartTime,
			&i.EndTime,
			&i.Building,
			&i.Room,
			&i.Sunday,
			&i.Monday,
			&i.Tuesday,
			&i.Wednesday,
			&i.Thursday,
			&i.Friday,
			&i.Saturday,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMeetingTimesByTerm = `-- name: GetMeetingTimesByTerm :many
SELECT
    m.section_id, m.start_time, m.end_time, m.building, m.room,
    m.sunday, m.monday, m.tuesday, m.wednesday, m.thursday, m.friday, m.saturday
FROM meeting_times m
JOIN sections s ON m.section_id = s.id
WHERE s.term = ?
ORDER BY m.section_id
`

type GetMeetingTimesByTermRow struct {
	SectionID int64          `json:"section_id"`
	StartTime sql.NullString `json:"start_time"`
	EndTime   sql.NullString `json:"end_time"`
	Building  sql.NullString `json:"building"`
	Room      sql.NullString `json:"room"`
	Sunday    sql.NullInt64  `json:"sunday"`
	Monday    sql.NullInt64  `json:"monday"`
	Tuesday   sql.NullInt64  `json:"tuesday"`
	Wednesday sql.NullInt64  `json:"wednesday"`
	Thursday  sql.NullInt64  `json:"thursday"`
	Friday    sql.NullInt64  `json:"friday"`
	Saturday  sql.NullInt64  `json:"saturday"`
}

func (q *Queries) GetMeetingTimesByTerm(ctx context.Context, term string) ([]*GetMeetingTimesByTermRow, error) {
	rows, err := q.db.QueryContext(ctx, getMeetingTimesByTerm, term)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetMeetingTimesByTermRow{}
	for rows.Next() {
		var i GetMeetingTimesByTermRow
		if err := rows.Scan(
			&i.SectionID,
			&i.StartTime,
			&i.EndTime,
			&i.Building,
			&i.Room,
			&i.Sunday,
			&i.Monday,
			&i.Tuesday,
			&i.Wednesday,
			&i.Thursday,
			&i.Friday,
			&i.Saturday,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPrimaryInstructorBySection = `-- name: GetPrimaryInstructorBySection :one
SELECT id, section_id, banner_id, name, email, is_primary FROM instructors WHERE section_id = ? AND is_primary = 1
`

func (q *Queries) GetPrimaryInstructorBySection(ctx context.Context, sectionID int64) (*Instructor, error) {
	row := q.db.QueryRowContext(ctx, getPrimaryInstructorBySection, sectionID)
	var i Instructor
	err := row.Scan(
		&i.ID,
		&i.SectionID,
		&i.BannerID,
		&i.Name,
		&i.Email,
		&i.IsPrimary,
	)
	return &i, err
}

const getSectionAttributesBySection = `-- name: GetSectionAttributesBySection :many
SELECT id, section_id, code, description FROM section_attributes WHERE section_id = ?
`

func (q *Queries) GetSectionAttributesBySection(ctx context.Context, sectionID int64) ([]*SectionAttribute, error) {
	rows, err := q.db.QueryContext(ctx, getSectionAttributesBySection, sectionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SectionAttribute{}
	for rows.Next() {
		var i SectionAttribute
		if err := rows.Scan(
			&i.ID,
			&i.SectionID,
			&i.Code,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSectionByTermAndCRN = `-- name: GetSectionByTermAndCRN :one
SELECT id, term, crn, subject, subject_description, course_number, sequence_number, title, campus, schedule_type, instructional_method, instructional_method_desc, credit_hours_low, credit_hours_high, enrollment, max_enrollment, seats_available, wait_capacity, wait_count, is_open, updated_at FROM sections WHERE term = ? AND crn = ?
`

type GetSectionByTermAndCRNParams struct {
	Term string `json:"term"`
	Crn  string `json:"crn"`
}

func (q *Queries) GetSectionByTermAndCRN(ctx context.Context, arg GetSectionByTermAndCRNParams) (*Section, error) {
	row := q.db.QueryRowContext(ctx, getSectionByTermAndCRN, arg.Term, arg.Crn)
	var i Section
	err := row.Scan(
		&i.ID,
		&i.Term,
		&i.Crn,
		&i.Subject,
		&i.SubjectDescription,
		&i.CourseNumber,
		&i.SequenceNumber,
		&i.Title,
		&i.Campus,
		&i.ScheduleType,
		&i.InstructionalMethod,
		&i.InstructionalMethodDesc,
		&i.CreditHoursLow,
		&i.CreditHoursHigh,
		&i.Enrollment,
		&i.MaxEnrollment,
		&i.SeatsAvailable,
		&i.WaitCapacity,
		&i.WaitCount,
		&i.IsOpen,
		&i.UpdatedAt,
	)
	return &i, err
}

const getSectionCount = `-- name: GetSectionCount :one
SELECT COUNT(*) FROM sections WHERE term = ?
`

func (q *Queries) GetSectionCount(ctx context.Context, term string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getSectionCount, term)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getSectionWithInstructorByTermAndCRN = `-- name: GetSectionWithInstructorByTermAndCRN :one
SELECT
    s.id, s.term, s.crn, s.subject, s.subject_description,
    s.course_number, s.title, s.credit_hours_low,
    s.enrollment, s.max_enrollment, s.seats_available, s.wait_count, s.is_open,
    s.instructional_method,
    i.name AS instructor_name, i.email AS instructor_email
FROM sections s
LEFT JOIN instructors i ON s.id = i.section_id AND i.is_primary = 1
WHERE s.term = ? AND s.crn = ?
`

type GetSectionWithInstructorByTermAndCRNParams struct {
	Term string `json:"term"`
	Crn  string `json:"crn"`
}

type GetSectionWithInstructorByTermAndCRNRow struct {
	ID                  int64          `json:"id"`
	Term                string         `json:"term"`
	Crn                 string         `json:"crn"`
	Subject             string         `json:"subject"`
	SubjectDescription  sql.NullString `json:"subject_description"`
	CourseNumber        string         `json:"course_number"`
	Title               string         `json:"title"`
	CreditHoursLow      sql.NullInt64  `json:"credit_hours_low"`
	Enrollment          sql.NullInt64  `json:"enrollment"`
	MaxEnrollment       sql.NullInt64  `json:"max_enrollment"`
	SeatsAvailable      sql.NullInt64  `json:"seats_available"`
	WaitCount           sql.NullInt64  `json:"wait_count"`
	IsOpen              sql.NullInt64  `json:"is_open"`
	InstructionalMethod sql.NullString `json:"instructional_method"`
	InstructorName      sql.NullString `json:"instructor_name"`
	InstructorEmail     sql.NullString `json:"instructor_email"`
}

func (q *Queries) GetSectionWithInstructorByTermAndCRN(ctx context.Context, arg GetSectionWithInstructorByTermAndCRNParams) (*GetSectionWithInstructorByTermAndCRNRow, error) {
	row := q.db.QueryRowContext(ctx, getSectionWithInstructorByTermAndCRN, arg.Term, arg.Crn)
	var i GetSectionWithInstructorByTermAndCRNRow
	err := row.Scan(
		&i.ID,
		&i.Term,
		&i.Crn,
		&i.Subject,
		&i.SubjectDescription,
		&i.CourseNumber,
		&i.Title,
		&i.CreditHoursLow,
		&i.Enrollment,
		&i.MaxEnrollment,
		&i.SeatsAvailable,
		&i.WaitCount,
		&i.IsOpen,
		&i.InstructionalMethod,
		&i.InstructorName,
		&i.InstructorEmail,
	)
	return &i, err
}

const getSectionsBySubject = `-- name: GetSectionsBySubject :many
SELECT id, term, crn, subject, subject_description, course_number, sequence_number, title, campus, schedule_type, instructional_method, instructional_method_desc, credit_hours_low, credit_hours_high, enrollment, max_enrollment, seats_available, wait_capacity, wait_count, is_open, updated_at FROM sections WHERE term = ? AND subject = ? ORDER BY course_number
`

type GetSectionsBySubjectParams struct {
	Term    string `json:"term"`
	Subject string `json:"subject"`
}

func (q *Queries) GetSectionsBySubject(ctx context.Context, arg GetSectionsBySubjectParams) ([]*Section, error) {
	rows, err := q.db.QueryContext(ctx, getSectionsBySubject, arg.Term, arg.Subject)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Section{}
	for rows.Next() {
		var i Section
		if err := rows.Scan(
			&i.ID,
			&i.Term,
			&i.Crn,
			&i.Subject,
			&i.SubjectDescription,
			&i.CourseNumber,
			&i.SequenceNumber,
			&i.Title,
			&i.Campus,
			&i.ScheduleType,
			&i.InstructionalMethod,
			&i.InstructionalMethodDesc,
			&i.CreditHoursLow,
			&i.CreditHoursHigh,
			&i.Enrollment,
			&i.MaxEnrollment,
			&i.SeatsAvailable,
			&i.WaitCapacity,
			&i.WaitCount,
			&i.IsOpen,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSectionsByTerm = `-- name: GetSectionsByTerm :many
SELECT id, term, crn, subject, subject_description, course_number, sequence_number, title, campus, schedule_type, instructional_method, instructional_method_desc, credit_hours_low, credit_hours_high, enrollment, max_enrollment, seats_available, wait_capacity, wait_count, is_open, updated_at FROM sections WHERE term = ? ORDER BY subject, course_number
`

func (q *Queries) GetSectionsByTerm(ctx context.Context, term string) ([]*Section, error) {
	rows, err := q.db.QueryContext(ctx, getSectionsByTerm, term)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Section{}
	for rows.Next() {
		var i Section
		if err := rows.Scan(
			&i.ID,
			&i.Term,
			&i.Crn,
			&i.Subject,
			&i.SubjectDescription,
			&i.CourseNumber,
			&i.SequenceNumber,
			&i.Title,
			&i.Campus,
			&i.ScheduleType,
			&i.InstructionalMethod,
			&i.InstructionalMethodDesc,
			&i.CreditHoursLow,
			&i.CreditHoursHigh,
			&i.Enrollment,
			&i.MaxEnrollment,
			&i.SeatsAvailable,
			&i.WaitCapacity,
			&i.WaitCount,
			&i.IsOpen,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSectionsWithInstructorByCourse = `-- name: GetSectionsWithInstructorByCourse :many
SELECT
    s.id, s.term, s.crn, s.subject, s.subject_description,
    s.course_number, s.title, s.credit_hours_low,
    s.enrollment, s.max_enrollment, s.seats_available, s.wait_count, s.is_open,
    s.instructional_method,
    i.name AS instructor_name, i.email AS instructor_email
FROM sections s
LEFT JOIN instructors i ON s.id = i.section_id AND i.is_primary = 1
WHERE s.term = ? AND s.subject = ? AND s.course_number = ?
ORDER BY s.crn
`

type GetSectionsWithInstructorByCourseParams struct {
	Term         string `json:"term"`
	Subject      string `json:"subject"`
	CourseNumber string `json:"course_number"`
}

type GetSectionsWithInstructorByCourseRow struct {
	ID                  int64          `json:"id"`
	Term                string         `json:"term"`
	Crn                 string         `json:"crn"`
	Subject             string         `json:"subject"`
	SubjectDescription  sql.NullString `json:"subject_description"`
	CourseNumber        string         `json:"course_number"`
	Title               string         `json:"title"`
	CreditHoursLow      sql.NullInt64  `json:"credit_hours_low"`
	Enrollment          sql.NullInt64  `json:"enrollment"`
	MaxEnrollment       sql.NullInt64  `json:"max_enrollment"`
	SeatsAvailable      sql.NullInt64  `json:"seats_available"`
	WaitCount           sql.NullInt64  `json:"wait_count"`
	IsOpen              sql.NullInt64  `json:"is_open"`
	InstructionalMethod sql.NullString `json:"instructional_method"`
	InstructorName      sql.NullString `json:"instructor_name"`
	InstructorEmail     sql.NullString `json:"instructor_email"`
}

func (q *Queries) GetSectionsWithInstructorByCourse(ctx context.Context, arg GetSectionsWithInstructorByCourseParams) ([]*GetSectionsWithInstructorByCourseRow, error) {
	rows, err := q.db.QueryContext(ctx, getSectionsWithInstructorByCourse, arg.Term, arg.Subject, arg.CourseNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetSectionsWithInstructorByCourseRow{}
	for rows.Next() {
		var i GetSectionsWithInstructorByCourseRow
		if err := rows.Scan(
			&i.ID,
			&i.Term,
			&i.Crn,
			&i.Subject,
			&i.SubjectDescription,
			&i.CourseNumber,
			&i.Title,
			&i.CreditHoursLow,
			&i.Enrollment,
			&i.MaxEnrollment,
			&i.SeatsAvailable,
			&i.WaitCount,
			&i.IsOpen,
			&i.InstructionalMethod,
			&i.InstructorName,
			&i.InstructorEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSectionsWithInstructorByTerm = `-- name: GetSectionsWithInstructorByTerm :many
SELECT
    s.id, s.term, s.crn, s.subject, s.subject_description,
    s.course_number, s.title, s.credit_hours_low,
    s.enrollment, s.max_enrollment, s.seats_available, s.wait_count, s.is_open,
    s.instructional_method,
    i.name AS instructor_name, i.email AS instructor_email
FROM sections s
LEFT JOIN instructors i ON s.id = i.section_id AND i.is_primary = 1
WHERE s.term = ?
ORDER BY s.id
`

type GetSectionsWithInstructorByTermRow struct {
	ID                  int64          `json:"id"`
	Term                string         `json:"term"`
	Crn                 string         `json:"crn"`
	Subject             string         `json:"subject"`
	SubjectDescription  sql.NullString `json:"subject_description"`
	CourseNumber        string         `json:"course_number"`
	Title               string         `json:"title"`
	CreditHoursLow      sql.NullInt64  `json:"credit_hours_low"`
	Enrollment          sql.NullInt64  `json:"enrollment"`
	MaxEnrollment       sql.NullInt64  `json:"max_enrollment"`
	SeatsAvailable      sql.NullInt64  `json:"seats_available"`
	WaitCount           sql.NullInt64  `json:"wait_count"`
	IsOpen              sql.NullInt64  `json:"is_open"`
	InstructionalMethod sql.NullString `json:"instructional_method"`
	InstructorName      sql.NullString `json:"instructor_name"`
	InstructorEmail     sql.NullString `json:"instructor_email"`
}

func (q *Queries) GetSectionsWithInstructorByTerm(ctx context.Context, term string) ([]*GetSectionsWithInstructorByTermRow, error) {
	rows, err := q.db.QueryContext(ctx, getSectionsWithInstructorByTerm, term)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetSectionsWithInstructorByTermRow{}
	for rows.Next() {
		var i GetSectionsWithInstructorByTermRow
		if err := rows.Scan(
			&i.ID,
			&i.Term,
			&i.Crn,
			&i.Subject,
			&i.SubjectDescription,
			&i.CourseNumber,
			&i.Title,
			&i.CreditHoursLow,
			&i.Enrollment,
			&i.MaxEnrollment,
			&i.SeatsAvailable,
			&i.WaitCount,
			&i.IsOpen,
			&i.InstructionalMethod,
			&i.InstructorName,
			&i.InstructorEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubjectsWithDescriptionsByTerm = `-- name: GetSubjectsWithDescriptionsByTerm :many
SELECT DISTINCT subject, subject_description
FROM sections
WHERE term = ?
ORDER BY subject
`

type GetSubjectsWithDescriptionsByTermRow struct {
	Subject            string         `json:"subject"`
	SubjectDescription sql.NullString `json:"subject_description"`
}

func (q *Queries) GetSubjectsWithDescriptionsByTerm(ctx context.Context, term string) ([]*GetSubjectsWithDescriptionsByTermRow, error) {
	rows, err := q.db.QueryContext(ctx, getSubjectsWithDescriptionsByTerm, term)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetSubjectsWithDescriptionsByTermRow{}
	for rows.Next() {
		var i GetSubjectsWithDescriptionsByTermRow
		if err := rows.Scan(&i.Subject, &i.SubjectDescription); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTermByCode = `-- name: GetTermByCode :one
SELECT code, description, last_scraped_at FROM terms WHERE code = ?
`

func (q *Queries) GetTermByCode(ctx context.Context, code string) (*Term, error) {
	row := q.db.QueryRowContext(ctx, getTermByCode, code)
	var i Term
	err := row.Scan(&i.Code, &i.Description, &i.LastScrapedAt)
	return &i, err
}

const getTerms = `-- name: GetTerms :many
SELECT code, description, last_scraped_at FROM terms ORDER BY code DESC
`

func (q *Queries) GetTerms(ctx context.Context) ([]*Term, error) {
	rows, err := q.db.QueryContext(ctx, getTerms)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Term{}
	for rows.Next() {
		var i Term
		if err := rows.Scan(&i.Code, &i.Description, &i.LastScrapedAt); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTermsNeverScraped = `-- name: GetTermsNeverScraped :many
SELECT code, description, last_scraped_at FROM terms
WHERE last_scraped_at IS NULL ORDER BY code DESC
`

func (q *Queries) GetTermsNeverScraped(ctx context.Context) ([]*Term, error) {
	rows, err := q.db.QueryContext(ctx, getTermsNeverScraped)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Term{}
	for rows.Next() {
		var i Term
		if err := rows.Scan(&i.Code, &i.Description, &i.LastScrapedAt); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertFeedback = `-- name: InsertFeedback :exec
INSERT INTO feedback (session_id, message) VALUES (?, ?)
`

type InsertFeedbackParams struct {
	SessionID sql.NullString `json:"session_id"`
	Message   string         `json:"message"`
}

func (q *Queries) InsertFeedback(ctx context.Context, arg InsertFeedbackParams) error {
	_, err := q.db.ExecContext(ctx, insertFeedback, arg.SessionID, arg.Message)
	return err
}

const insertInstructor = `-- name: InsertInstructor :exec
INSERT INTO instructors (section_id, banner_id, name, email, is_primary)
VALUES (?, ?, ?, ?, ?)
`

type InsertInstructorParams struct {
	SectionID int64          `json:"section_id"`
	BannerID  sql.NullString `json:"banner_id"`
	Name      string         `json:"name"`
	Email     sql.NullString `json:"email"`
	IsPrimary sql.NullInt64  `json:"is_primary"`
}

func (q *Queries) InsertInstructor(ctx context.Context, arg InsertInstructorParams) error {
	_, err := q.db.ExecContext(ctx, insertInstructor,
		arg.SectionID,
		arg.BannerID,
		arg.Name,
		arg.Email,
		arg.IsPrimary,
	)
	return err
}

const insertMeetingTime = `-- name: InsertMeetingTime :exec
INSERT INTO meeting_times (
    section_id, start_time, end_time, start_date, end_date,
    building, building_description, room,
    monday, tuesday, wednesday, thursday, friday, saturday, sunday,
    schedule_type, meeting_type, credit_hours, hours_per_week
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type InsertMeetingTimeParams struct {
	SectionID           int64           `json:"section_id"`
	StartTime           sql.NullString  `json:"start_time"`
	EndTime             sql.NullString  `json:"end_time"`
	StartDate           sql.NullString  `json:"start_date"`
	EndDate             sql.NullString  `json:"end_date"`
	Building            sql.NullString  `json:"building"`
	BuildingDescription sql.NullString  `json:"building_description"`
	Room                sql.NullString  `json:"room"`
	Monday              sql.NullInt64   `json:"monday"`
	Tuesday             sql.NullInt64   `json:"tuesday"`
	Wednesday           sql.NullInt64   `json:"wednesday"`
	Thursday            sql.NullInt64   `json:"thursday"`
	Friday              sql.NullInt64   `json:"friday"`
	Saturday            sql.NullInt64   `json:"saturday"`
	Sunday              sql.NullInt64   `json:"sunday"`
	ScheduleType        sql.NullString  `json:"schedule_type"`
	MeetingType         sql.NullString  `json:"meeting_type"`
	CreditHours         sql.NullFloat64 `json:"credit_hours"`
	HoursPerWeek        sql.NullFloat64 `json:"hours_per_week"`
}

func (q *Queries) InsertMeetingTime(ctx context.Context, arg InsertMeetingTimeParams) error {
	_, err := q.db.ExecContext(ctx, insertMeetingTime,
		arg.SectionID,
		arg.StartTime,
		arg.EndTime,
		arg.StartDate,
		arg.EndDate,
		arg.Building,
		arg.BuildingDescription,
		arg.Room,
		arg.Monday,
		arg.Tuesday,
		arg.Wednesday,
		arg.Thursday,
		arg.Friday,
		arg.Saturday,
		arg.Sunday,
		arg.ScheduleType,
		arg.MeetingType,
		arg.CreditHours,
		arg.HoursPerWeek,
	)
	return err
}

const insertSectionAttribute = `-- name: InsertSectionAttribute :exec
INSERT INTO section_attributes (section_id, code, description)
VALUES (?, ?, ?)
`

type InsertSectionAttributeParams struct {
	SectionID   int64          `json:"section_id"`
	Code        string         `json:"code"`
	Description sql.NullString `json:"description"`
}

func (q *Queries) InsertSectionAttribute(ctx context.Context, arg InsertSectionAttributeParams) error {
	_, err := q.db.ExecContext(ctx, insertSectionAttribute, arg.SectionID, arg.Code, arg.Description)
	return err
}

const logGeneration = `-- name: LogGeneration :one
INSERT INTO generation_logs (
    session_id, term, courses_count, schedules_generated,
    min_courses, max_courses, blocked_times_count, duration_ms
) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id
`

type LogGenerationParams struct {
	SessionID          sql.NullString  `json:"session_id"`
	Term               string          `json:"term"`
	CoursesCount       int64           `json:"courses_count"`
	SchedulesGenerated int64           `json:"schedules_generated"`
	MinCourses         sql.NullInt64   `json:"min_courses"`
	MaxCourses         sql.NullInt64   `json:"max_courses"`
	BlockedTimesCount  int64           `json:"blocked_times_count"`
	DurationMs         sql.NullFloat64 `json:"duration_ms"`
}

func (q *Queries) LogGeneration(ctx context.Context, arg LogGenerationParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, logGeneration,
		arg.SessionID,
		arg.Term,
		arg.CoursesCount,
		arg.SchedulesGenerated,
		arg.MinCourses,
		arg.MaxCourses,
		arg.BlockedTimesCount,
		arg.DurationMs,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const logGenerationCourse = `-- name: LogGenerationCourse :exec
INSERT INTO generation_log_courses (
    generation_log_id, subject, course_number, required
) VALUES (?, ?, ?, ?)
`

type LogGenerationCourseParams struct {
	GenerationLogID int64  `json:"generation_log_id"`
	Subject         string `json:"subject"`
	CourseNumber    string `json:"course_number"`
	Required        int64  `json:"required"`
}

func (q *Queries) LogGenerationCourse(ctx context.Context, arg LogGenerationCourseParams) error {
	_, err := q.db.ExecContext(ctx, logGenerationCourse,
		arg.GenerationLogID,
		arg.Subject,
		arg.CourseNumber,
		arg.Required,
	)
	return err
}

const logSearch = `-- name: LogSearch :exec
INSERT INTO search_logs (
    session_id, term, scope, subject, course_number,
    title, instructor, open_seats, min_credits, max_credits,
    results_count, duration_ms
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type LogSearchParams struct {
	SessionID    sql.NullString  `json:"session_id"`
	Term         sql.NullString  `json:"term"`
	Scope        sql.NullString  `json:"scope"`
	Subject      sql.NullString  `json:"subject"`
	CourseNumber sql.NullString  `json:"course_number"`
	Title        sql.NullString  `json:"title"`
	Instructor   sql.NullString  `json:"instructor"`
	OpenSeats    int64           `json:"open_seats"`
	MinCredits   sql.NullInt64   `json:"min_credits"`
	MaxCredits   sql.NullInt64   `json:"max_credits"`
	ResultsCount int64           `json:"results_count"`
	DurationMs   sql.NullFloat64 `json:"duration_ms"`
}

func (q *Queries) LogSearch(ctx context.Context, arg LogSearchParams) error {
	_, err := q.db.ExecContext(ctx, logSearch,
		arg.SessionID,
		arg.Term,
		arg.Scope,
		arg.Subject,
		arg.CourseNumber,
		arg.Title,
		arg.Instructor,
		arg.OpenSeats,
		arg.MinCredits,
		arg.MaxCredits,
		arg.ResultsCount,
		arg.DurationMs,
	)
	return err
}

const searchSections = `-- name: SearchSections :many
SELECT
    s.id, s.term, s.crn, s.subject, s.subject_description,
    s.course_number, s.title, s.credit_hours_low, s.credit_hours_high,
    s.enrollment, s.max_enrollment, s.seats_available, s.wait_count, s.is_open,
    s.instructional_method, s.schedule_type, s.campus,
    i.name AS instructor_name, i.email AS instructor_email
FROM sections s
LEFT JOIN instructors i ON s.id = i.section_id AND i.is_primary = 1
WHERE
    -- Term filter (NULL = all terms)
    (?1 IS NULL OR s.term = ?1)
    -- Subject filter (exact match)
    AND (?2 IS NULL OR s.subject = ?2)
    -- Course number filter (supports LIKE for wildcards)
    AND (?3 IS NULL OR s.course_number LIKE ?3)
    -- Title tokens (up to 3)
    AND (?4 IS NULL OR LOWER(s.title) LIKE '%' || LOWER(?4) || '%')
    AND (?5 IS NULL OR LOWER(s.title) LIKE '%' || LOWER(?5) || '%')
    AND (?6 IS NULL OR LOWER(s.title) LIKE '%' || LOWER(?6) || '%')
    -- Instructor tokens (up to 3)
    AND (?7 IS NULL OR LOWER(i.name) LIKE '%' || LOWER(?7) || '%')
    AND (?8 IS NULL OR LOWER(i.name) LIKE '%' || LOWER(?8) || '%')
    AND (?9 IS NULL OR LOWER(i.name) LIKE '%' || LOWER(?9) || '%')
    -- Open seats filter
    AND (?10 IS NULL OR ?10 = 0 OR s.seats_available > 0)
    -- Credit range
    AND (?11 IS NULL OR s.credit_hours_low >= ?11)
    AND (?12 IS NULL OR s.credit_hours_low <= ?12)
ORDER BY s.term DESC, s.subject, s.course_number, s.crn
LIMIT ?13
`

type SearchSectionsParams struct {
	Term         interface{} `json:"term"`
	Subject      interface{} `json:"subject"`
	CourseNumber interface{} `json:"course_number"`
	TitleT1      interface{} `json:"title_t1"`
	TitleT2      interface{} `json:"title_t2"`
	TitleT3      interface{} `json:"title_t3"`
	InstrT1      interface{} `json:"instr_t1"`
	InstrT2      interface{} `json:"instr_t2"`
	InstrT3      interface{} `json:"instr_t3"`
	OpenSeats    interface{} `json:"open_seats"`
	MinCredits   interface{} `json:"min_credits"`
	MaxCredits   interface{} `json:"max_credits"`
	ResultLimit  int64       `json:"result_limit"`
}

type SearchSectionsRow struct {
	ID                  int64          `json:"id"`
	Term                string         `json:"term"`
	Crn                 string         `json:"crn"`
	Subject             string         `json:"subject"`
	SubjectDescription  sql.NullString `json:"subject_description"`
	CourseNumber        string         `json:"course_number"`
	Title               string         `json:"title"`
	CreditHoursLow      sql.NullInt64  `json:"credit_hours_low"`
	CreditHoursHigh     sql.NullInt64  `json:"credit_hours_high"`
	Enrollment          sql.NullInt64  `json:"enrollment"`
	MaxEnrollment       sql.NullInt64  `json:"max_enrollment"`
	SeatsAvailable      sql.NullInt64  `json:"seats_available"`
	WaitCount           sql.NullInt64  `json:"wait_count"`
	IsOpen              sql.NullInt64  `json:"is_open"`
	InstructionalMethod sql.NullString `json:"instructional_method"`
	ScheduleType        sql.NullString `json:"schedule_type"`
	Campus              sql.NullString `json:"campus"`
	InstructorName      sql.NullString `json:"instructor_name"`
	InstructorEmail     sql.NullString `json:"instructor_email"`
}

func (q *Queries) SearchSections(ctx context.Context, arg SearchSectionsParams) ([]*SearchSectionsRow, error) {
	rows, err := q.db.QueryContext(ctx, searchSections,
		arg.Term,
		arg.Subject,
		arg.CourseNumber,
		arg.TitleT1,
		arg.TitleT2,
		arg.TitleT3,
		arg.InstrT1,
		arg.InstrT2,
		arg.InstrT3,
		arg.OpenSeats,
		arg.MinCredits,
		arg.MaxCredits,
		arg.ResultLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SearchSectionsRow{}
	for rows.Next() {
		var i SearchSectionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Term,
			&i.Crn,
			&i.Subject,
			&i.SubjectDescription,
			&i.CourseNumber,
			&i.Title,
			&i.CreditHoursLow,
			&i.CreditHoursHigh,
			&i.Enrollment,
			&i.MaxEnrollment,
			&i.SeatsAvailable,
			&i.WaitCount,
			&i.IsOpen,
			&i.InstructionalMethod,
			&i.ScheduleType,
			&i.Campus,
			&i.InstructorName,
			&i.InstructorEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTermScrapedAt = `-- name: UpdateTermScrapedAt :exec
UPDATE terms SET last_scraped_at = CURRENT_TIMESTAMP WHERE code = ?
`

func (q *Queries) UpdateTermScrapedAt(ctx context.Context, code string) error {
	_, err := q.db.ExecContext(ctx, updateTermScrapedAt, code)
	return err
}

const upsertSection = `-- name: UpsertSection :one
INSERT INTO sections (
    term, crn, subject, subject_description, course_number, sequence_number,
    title, campus, schedule_type, instructional_method, instructional_method_desc,
    credit_hours_low, credit_hours_high, enrollment, max_enrollment, seats_available,
    wait_capacity, wait_count, is_open, updated_at
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
ON CONFLICT(term, crn) DO UPDATE SET
    subject = excluded.subject,
    subject_description = excluded.subject_description,
    course_number = excluded.course_number,
    sequence_number = excluded.sequence_number,
    title = excluded.title,
    campus = excluded.campus,
    schedule_type = excluded.schedule_type,
    instructional_method = excluded.instructional_method,
    instructional_method_desc = excluded.instructional_method_desc,
    credit_hours_low = excluded.credit_hours_low,
    credit_hours_high = excluded.credit_hours_high,
    enrollment = excluded.enrollment,
    max_enrollment = excluded.max_enrollment,
    seats_available = excluded.seats_available,
    wait_capacity = excluded.wait_capacity,
    wait_count = excluded.wait_count,
    is_open = excluded.is_open,
    updated_at = CURRENT_TIMESTAMP
RETURNING id
`

type UpsertSectionParams struct {
	Term                    string         `json:"term"`
	Crn                     string         `json:"crn"`
	Subject                 string         `json:"subject"`
	SubjectDescription      sql.NullString `json:"subject_description"`
	CourseNumber            string         `json:"course_number"`
	SequenceNumber          sql.NullString `json:"sequence_number"`
	Title                   string         `json:"title"`
	Campus                  sql.NullString `json:"campus"`
	ScheduleType            sql.NullString `json:"schedule_type"`
	InstructionalMethod     sql.NullString `json:"instructional_method"`
	InstructionalMethodDesc sql.NullString `json:"instructional_method_desc"`
	CreditHoursLow          sql.NullInt64  `json:"credit_hours_low"`
	CreditHoursHigh         sql.NullInt64  `json:"credit_hours_high"`
	Enrollment              sql.NullInt64  `json:"enrollment"`
	MaxEnrollment           sql.NullInt64  `json:"max_enrollment"`
	SeatsAvailable          sql.NullInt64  `json:"seats_available"`
	WaitCapacity            sql.NullInt64  `json:"wait_capacity"`
	WaitCount               sql.NullInt64  `json:"wait_count"`
	IsOpen                  sql.NullInt64  `json:"is_open"`
}

func (q *Queries) UpsertSection(ctx context.Context, arg UpsertSectionParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, upsertSection,
		arg.Term,
		arg.Crn,
		arg.Subject,
		arg.SubjectDescription,
		arg.CourseNumber,
		arg.SequenceNumber,
		arg.Title,
		arg.Campus,
		arg.ScheduleType,
		arg.InstructionalMethod,
		arg.InstructionalMethodDesc,
		arg.CreditHoursLow,
		arg.CreditHoursHigh,
		arg.Enrollment,
		arg.MaxEnrollment,
		arg.SeatsAvailable,
		arg.WaitCapacity,
		arg.WaitCount,
		arg.IsOpen,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const upsertTerm = `-- name: UpsertTerm :exec
INSERT INTO terms (code, description)
VALUES (?, ?)
ON CONFLICT(code) DO UPDATE SET description = excluded.description
`

type UpsertTermParams struct {
	Code        string `json:"code"`
	Description string `json:"description"`
}

func (q *Queries) UpsertTerm(ctx context.Context, arg UpsertTermParams) error {
	_, err := q.db.ExecContext(ctx, upsertTerm, arg.Code, arg.Description)
	return err
}

const validateCourseForTerm = `-- name: ValidateCourseForTerm :one
SELECT
    COUNT(*) AS section_count,
    COALESCE(MAX(title), '') AS title
FROM sections
WHERE term = ? AND subject = ? AND course_number = ?
`

type ValidateCourseForTermParams struct {
	Term         string `json:"term"`
	Subject      string `json:"subject"`
	CourseNumber string `json:"course_number"`
}

type ValidateCourseForTermRow struct {
	SectionCount int64       `json:"section_count"`
	Title        interface{} `json:"title"`
}

func (q *Queries) ValidateCourseForTerm(ctx context.Context, arg ValidateCourseForTermParams) (*ValidateCourseForTermRow, error) {
	row := q.db.QueryRowContext(ctx, validateCourseForTerm, arg.Term, arg.Subject, arg.CourseNumber)
	var i ValidateCourseForTermRow
	err := row.Scan(&i.SectionCount, &i.Title)
	return &i, err
}
