// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package store

import (
	"context"
	"database/sql"
)

const courseExistsAnyTerm = `-- name: CourseExistsAnyTerm :one
SELECT EXISTS(
    SELECT 1 FROM sections
    WHERE subject = ? AND course_number = ?
) AS course_exists
`

type CourseExistsAnyTermParams struct {
	Subject      string `json:"subject"`
	CourseNumber string `json:"course_number"`
}

func (q *Queries) CourseExistsAnyTerm(ctx context.Context, arg CourseExistsAnyTermParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, courseExistsAnyTerm, arg.Subject, arg.CourseNumber)
	var course_exists int64
	err := row.Scan(&course_exists)
	return course_exists, err
}

const deleteInstructorsBySection = `-- name: DeleteInstructorsBySection :exec
DELETE FROM instructors WHERE section_id = ?
`

func (q *Queries) DeleteInstructorsBySection(ctx context.Context, sectionID int64) error {
	_, err := q.db.ExecContext(ctx, deleteInstructorsBySection, sectionID)
	return err
}

const deleteMeetingTimesBySection = `-- name: DeleteMeetingTimesBySection :exec
DELETE FROM meeting_times WHERE section_id = ?
`

func (q *Queries) DeleteMeetingTimesBySection(ctx context.Context, sectionID int64) error {
	_, err := q.db.ExecContext(ctx, deleteMeetingTimesBySection, sectionID)
	return err
}

const deleteSectionAttributesBySection = `-- name: DeleteSectionAttributesBySection :exec
DELETE FROM section_attributes WHERE section_id = ?
`

func (q *Queries) DeleteSectionAttributesBySection(ctx context.Context, sectionID int64) error {
	_, err := q.db.ExecContext(ctx, deleteSectionAttributesBySection, sectionID)
	return err
}

const deleteSectionsByTerm = `-- name: DeleteSectionsByTerm :exec
DELETE FROM sections WHERE term = ?
`

func (q *Queries) DeleteSectionsByTerm(ctx context.Context, term string) error {
	_, err := q.db.ExecContext(ctx, deleteSectionsByTerm, term)
	return err
}

const getDistinctSubjects = `-- name: GetDistinctSubjects :many
SELECT DISTINCT subject FROM sections ORDER BY subject
`

func (q *Queries) GetDistinctSubjects(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getDistinctSubjects)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var subject string
		if err := rows.Scan(&subject); err != nil {
			return nil, err
		}
		items = append(items, subject)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDistinctSubjectsByTerm = `-- name: GetDistinctSubjectsByTerm :many
SELECT DISTINCT subject FROM sections WHERE term = ? ORDER BY subject
`

func (q *Queries) GetDistinctSubjectsByTerm(ctx context.Context, term string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getDistinctSubjectsByTerm, term)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var subject string
		if err := rows.Scan(&subject); err != nil {
			return nil, err
		}
		items = append(items, subject)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDistinctTerms = `-- name: GetDistinctTerms :many
SELECT DISTINCT term FROM sections ORDER BY term DESC
`

func (q *Queries) GetDistinctTerms(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getDistinctTerms)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var term string
		if err := rows.Scan(&term); err != nil {
			return nil, err
		}
		items = append(items, term)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInstructorsBySection = `-- name: GetInstructorsBySection :many
SELECT id, section_id, banner_id, name, email, is_primary FROM instructors WHERE section_id = ?
`

func (q *Queries) GetInstructorsBySection(ctx context.Context, sectionID int64) ([]*Instructor, error) {
	rows, err := q.db.QueryContext(ctx, getInstructorsBySection, sectionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Instructor{}
	for rows.Next() {
		var i Instructor
		if err := rows.Scan(
			&i.ID,
			&i.SectionID,
			&i.BannerID,
			&i.Name,
			&i.Email,
			&i.IsPrimary,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMeetingTimesBySection = `-- name: GetMeetingTimesBySection :many
SELECT id, section_id, start_time, end_time, start_date, end_date, building, building_description, room, monday, tuesday, wednesday, thursday, friday, saturday, sunday, schedule_type, meeting_type, credit_hours, hours_per_week FROM meeting_times WHERE section_id = ?
`

func (q *Queries) GetMeetingTimesBySection(ctx context.Context, sectionID int64) ([]*MeetingTime, error) {
	rows, err := q.db.QueryContext(ctx, getMeetingTimesBySection, sectionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*MeetingTime{}
	for rows.Next() {
		var i MeetingTime
		if err := rows.Scan(
			&i.ID,
			&i.SectionID,
			&i.StartTime,
			&i.EndTime,
			&i.StartDate,
			&i.EndDate,
			&i.Building,
			&i.BuildingDescription,
			&i.Room,
			&i.Monday,
			&i.Tuesday,
			&i.Wednesday,
			&i.Thursday,
			&i.Friday,
			&i.Saturday,
			&i.Sunday,
			&i.ScheduleType,
			&i.MeetingType,
			&i.CreditHours,
			&i.HoursPerWeek,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMeetingTimesByTerm = `-- name: GetMeetingTimesByTerm :many
SELECT
    m.section_id, m.start_time, m.end_time, m.building, m.room,
    m.sunday, m.monday, m.tuesday, m.wednesday, m.thursday, m.friday, m.saturday
FROM meeting_times m
JOIN sections s ON m.section_id = s.id
WHERE s.term = ?
ORDER BY m.section_id
`

type GetMeetingTimesByTermRow struct {
	SectionID int64          `json:"section_id"`
	StartTime sql.NullString `json:"start_time"`
	EndTime   sql.NullString `json:"end_time"`
	Building  sql.NullString `json:"building"`
	Room      sql.NullString `json:"room"`
	Sunday    sql.NullInt64  `json:"sunday"`
	Monday    sql.NullInt64  `json:"monday"`
	Tuesday   sql.NullInt64  `json:"tuesday"`
	Wednesday sql.NullInt64  `json:"wednesday"`
	Thursday  sql.NullInt64  `json:"thursday"`
	Friday    sql.NullInt64  `json:"friday"`
	Saturday  sql.NullInt64  `json:"saturday"`
}

func (q *Queries) GetMeetingTimesByTerm(ctx context.Context, term string) ([]*GetMeetingTimesByTermRow, error) {
	rows, err := q.db.QueryContext(ctx, getMeetingTimesByTerm, term)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetMeetingTimesByTermRow{}
	for rows.Next() {
		var i GetMeetingTimesByTermRow
		if err := rows.Scan(
			&i.SectionID,
			&i.StartTime,
			&i.EndTime,
			&i.Building,
			&i.Room,
			&i.Sunday,
			&i.Monday,
			&i.Tuesday,
			&i.Wednesday,
			&i.Thursday,
			&i.Friday,
			&i.Saturday,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPrimaryInstructorBySection = `-- name: GetPrimaryInstructorBySection :one
SELECT id, section_id, banner_id, name, email, is_primary FROM instructors WHERE section_id = ? AND is_primary = 1
`

func (q *Queries) GetPrimaryInstructorBySection(ctx context.Context, sectionID int64) (*Instructor, error) {
	row := q.db.QueryRowContext(ctx, getPrimaryInstructorBySection, sectionID)
	var i Instructor
	err := row.Scan(
		&i.ID,
		&i.SectionID,
		&i.BannerID,
		&i.Name,
		&i.Email,
		&i.IsPrimary,
	)
	return &i, err
}

const getSectionAttributesBySection = `-- name: GetSectionAttributesBySection :many
SELECT id, section_id, code, description FROM section_attributes WHERE section_id = ?
`

func (q *Queries) GetSectionAttributesBySection(ctx context.Context, sectionID int64) ([]*SectionAttribute, error) {
	rows, err := q.db.QueryContext(ctx, getSectionAttributesBySection, sectionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SectionAttribute{}
	for rows.Next() {
		var i SectionAttribute
		if err := rows.Scan(
			&i.ID,
			&i.SectionID,
			&i.Code,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSectionByTermAndCRN = `-- name: GetSectionByTermAndCRN :one
SELECT id, term, crn, subject, subject_description, course_number, sequence_number, title, campus, schedule_type, instructional_method, instructional_method_desc, credit_hours_low, credit_hours_high, enrollment, max_enrollment, seats_available, wait_capacity, wait_count, is_open, updated_at FROM sections WHERE term = ? AND crn = ?
`

type GetSectionByTermAndCRNParams struct {
	Term string `json:"term"`
	Crn  string `json:"crn"`
}

func (q *Queries) GetSectionByTermAndCRN(ctx context.Context, arg GetSectionByTermAndCRNParams) (*Section, error) {
	row := q.db.QueryRowContext(ctx, getSectionByTermAndCRN, arg.Term, arg.Crn)
	var i Section
	err := row.Scan(
		&i.ID,
		&i.Term,
		&i.Crn,
		&i.Subject,
		&i.SubjectDescription,
		&i.CourseNumber,
		&i.SequenceNumber,
		&i.Title,
		&i.Campus,
		&i.ScheduleType,
		&i.InstructionalMethod,
		&i.InstructionalMethodDesc,
		&i.CreditHoursLow,
		&i.CreditHoursHigh,
		&i.Enrollment,
		&i.MaxEnrollment,
		&i.SeatsAvailable,
		&i.WaitCapacity,
		&i.WaitCount,
		&i.IsOpen,
		&i.UpdatedAt,
	)
	return &i, err
}

const getSectionCount = `-- name: GetSectionCount :one
SELECT COUNT(*) FROM sections WHERE term = ?
`

func (q *Queries) GetSectionCount(ctx context.Context, term string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getSectionCount, term)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getSectionWithInstructorByTermAndCRN = `-- name: GetSectionWithInstructorByTermAndCRN :one
SELECT
    s.id, s.term, s.crn, s.subject, s.subject_description,
    s.course_number, s.title, s.credit_hours_low,
    s.enrollment, s.max_enrollment, s.seats_available, s.wait_count, s.is_open,
    s.instructional_method,
    i.name AS instructor_name, i.email AS instructor_email
FROM sections s
LEFT JOIN instructors i ON s.id = i.section_id AND i.is_primary = 1
WHERE s.term = ? AND s.crn = ?
`

type GetSectionWithInstructorByTermAndCRNParams struct {
	Term string `json:"term"`
	Crn  string `json:"crn"`
}

type GetSectionWithInstructorByTermAndCRNRow struct {
	ID                  int64          `json:"id"`
	Term                string         `json:"term"`
	Crn                 string         `json:"crn"`
	Subject             string         `json:"subject"`
	SubjectDescription  sql.NullString `json:"subject_description"`
	CourseNumber        string         `json:"course_number"`
	Title               string         `json:"title"`
	CreditHoursLow      sql.NullInt64  `json:"credit_hours_low"`
	Enrollment          sql.NullInt64  `json:"enrollment"`
	MaxEnrollment       sql.NullInt64  `json:"max_enrollment"`
	SeatsAvailable      sql.NullInt64  `json:"seats_available"`
	WaitCount           sql.NullInt64  `json:"wait_count"`
	IsOpen              sql.NullInt64  `json:"is_open"`
	InstructionalMethod sql.NullString `json:"instructional_method"`
	InstructorName      sql.NullString `json:"instructor_name"`
	InstructorEmail     sql.NullString `json:"instructor_email"`
}

func (q *Queries) GetSectionWithInstructorByTermAndCRN(ctx context.Context, arg GetSectionWithInstructorByTermAndCRNParams) (*GetSectionWithInstructorByTermAndCRNRow, error) {
	row := q.db.QueryRowContext(ctx, getSectionWithInstructorByTermAndCRN, arg.Term, arg.Crn)
	var i GetSectionWithInstructorByTermAndCRNRow
	err := row.Scan(
		&i.ID,
		&i.Term,
		&i.Crn,
		&i.Subject,
		&i.SubjectDescription,
		&i.CourseNumber,
		&i.Title,
		&i.CreditHoursLow,
		&i.Enrollment,
		&i.MaxEnrollment,
		&i.SeatsAvailable,
		&i.WaitCount,
		&i.IsOpen,
		&i.InstructionalMethod,
		&i.InstructorName,
		&i.InstructorEmail,
	)
	return &i, err
}

const getSectionsBySubject = `-- name: GetSectionsBySubject :many
SELECT id, term, crn, subject, subject_description, course_number, sequence_number, title, campus, schedule_type, instructional_method, instructional_method_desc, credit_hours_low, credit_hours_high, enrollment, max_enrollment, seats_available, wait_capacity, wait_count, is_open, updated_at FROM sections WHERE term = ? AND subject = ? ORDER BY course_number
`

type GetSectionsBySubjectParams struct {
	Term    string `json:"term"`
	Subject string `json:"subject"`
}

func (q *Queries) GetSectionsBySubject(ctx context.Context, arg GetSectionsBySubjectParams) ([]*Section, error) {
	rows, err := q.db.QueryContext(ctx, getSectionsBySubject, arg.Term, arg.Subject)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Section{}
	for rows.Next() {
		var i Section
		if err := rows.Scan(
			&i.ID,
			&i.Term,
			&i.Crn,
			&i.Subject,
			&i.SubjectDescription,
			&i.CourseNumber,
			&i.SequenceNumber,
			&i.Title,
			&i.Campus,
			&i.ScheduleType,
			&i.InstructionalMethod,
			&i.InstructionalMethodDesc,
			&i.CreditHoursLow,
			&i.CreditHoursHigh,
			&i.Enrollment,
			&i.MaxEnrollment,
			&i.SeatsAvailable,
			&i.WaitCapacity,
			&i.WaitCount,
			&i.IsOpen,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSectionsByTerm = `-- name: GetSectionsByTerm :many
SELECT id, term, crn, subject, subject_description, course_number, sequence_number, title, campus, schedule_type, instructional_method, instructional_method_desc, credit_hours_low, credit_hours_high, enrollment, max_enrollment, seats_available, wait_capacity, wait_count, is_open, updated_at FROM sections WHERE term = ? ORDER BY subject, course_number
`

func (q *Queries) GetSectionsByTerm(ctx context.Context, term string) ([]*Section, error) {
	rows, err := q.db.QueryContext(ctx, getSectionsByTerm, term)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Section{}
	for rows.Next() {
		var i Section
		if err := rows.Scan(
			&i.ID,
			&i.Term,
			&i.Crn,
			&i.Subject,
			&i.SubjectDescription,
			&i.CourseNumber,
			&i.SequenceNumber,
			&i.Title,
			&i.Campus,
			&i.ScheduleType,
			&i.InstructionalMethod,
			&i.InstructionalMethodDesc,
			&i.CreditHoursLow,
			&i.CreditHoursHigh,
			&i.Enrollment,
			&i.MaxEnrollment,
			&i.SeatsAvailable,
			&i.WaitCapacity,
			&i.WaitCount,
			&i.IsOpen,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSectionsWithInstructorByCourse = `-- name: GetSectionsWithInstructorByCourse :many
SELECT
    s.id, s.term, s.crn, s.subject, s.subject_description,
    s.course_number, s.title, s.credit_hours_low,
    s.enrollment, s.max_enrollment, s.seats_available, s.wait_count, s.is_open,
    s.instructional_method,
    i.name AS instructor_name, i.email AS instructor_email
FROM sections s
LEFT JOIN instructors i ON s.id = i.section_id AND i.is_primary = 1
WHERE s.term = ? AND s.subject = ? AND s.course_number = ?
ORDER BY s.crn
`

type GetSectionsWithInstructorByCourseParams struct {
	Term         string `json:"term"`
	Subject      string `json:"subject"`
	CourseNumber string `json:"course_number"`
}

type GetSectionsWithInstructorByCourseRow struct {
	ID                  int64          `json:"id"`
	Term                string         `json:"term"`
	Crn                 string         `json:"crn"`
	Subject             string         `json:"subject"`
	SubjectDescription  sql.NullString `json:"subject_description"`
	CourseNumber        string         `json:"course_number"`
	Title               string         `json:"title"`
	CreditHoursLow      sql.NullInt64  `json:"credit_hours_low"`
	Enrollment          sql.NullInt64  `json:"enrollment"`
	MaxEnrollment       sql.NullInt64  `json:"max_enrollment"`
	SeatsAvailable      sql.NullInt64  `json:"seats_available"`
	WaitCount           sql.NullInt64  `json:"wait_count"`
	IsOpen              sql.NullInt64  `json:"is_open"`
	InstructionalMethod sql.NullString `json:"instructional_method"`
	InstructorName      sql.NullString `json:"instructor_name"`
	InstructorEmail     sql.NullString `json:"instructor_email"`
}

func (q *Queries) GetSectionsWithInstructorByCourse(ctx context.Context, arg GetSectionsWithInstructorByCourseParams) ([]*GetSectionsWithInstructorByCourseRow, error) {
	rows, err := q.db.QueryContext(ctx, getSectionsWithInstructorByCourse, arg.Term, arg.Subject, arg.CourseNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetSectionsWithInstructorByCourseRow{}
	for rows.Next() {
		var i GetSectionsWithInstructorByCourseRow
		if err := rows.Scan(
			&i.ID,
			&i.Term,
			&i.Crn,
			&i.Subject,
			&i.SubjectDescription,
			&i.CourseNumber,
			&i.Title,
			&i.CreditHoursLow,
			&i.Enrollment,
			&i.MaxEnrollment,
			&i.SeatsAvailable,
			&i.WaitCount,
			&i.IsOpen,
			&i.InstructionalMethod,
			&i.InstructorName,
			&i.InstructorEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSectionsWithInstructorByTerm = `-- name: GetSectionsWithInstructorByTerm :many
SELECT
    s.id, s.term, s.crn, s.subject, s.subject_description,
    s.course_number, s.title, s.credit_hours_low,
    s.enrollment, s.max_enrollment, s.seats_available, s.wait_count, s.is_open,
    s.instructional_method,
    i.name AS instructor_name, i.email AS instructor_email
FROM sections s
LEFT JOIN instructors i ON s.id = i.section_id AND i.is_primary = 1
WHERE s.term = ?
ORDER BY s.id
`

type GetSectionsWithInstructorByTermRow struct {
	ID                  int64          `json:"id"`
	Term                string         `json:"term"`
	Crn                 string         `json:"crn"`
	Subject             string         `json:"subject"`
	SubjectDescription  sql.NullString `json:"subject_description"`
	CourseNumber        string         `json:"course_number"`
	Title               string         `json:"title"`
	CreditHoursLow      sql.NullInt64  `json:"credit_hours_low"`
	Enrollment          sql.NullInt64  `json:"enrollment"`
	MaxEnrollment       sql.NullInt64  `json:"max_enrollment"`
	SeatsAvailable      sql.NullInt64  `json:"seats_available"`
	WaitCount           sql.NullInt64  `json:"wait_count"`
	IsOpen              sql.NullInt64  `json:"is_open"`
	InstructionalMethod sql.NullString `json:"instructional_method"`
	InstructorName      sql.NullString `json:"instructor_name"`
	InstructorEmail     sql.NullString `json:"instructor_email"`
}

func (q *Queries) GetSectionsWithInstructorByTerm(ctx context.Context, term string) ([]*GetSectionsWithInstructorByTermRow, error) {
	rows, err := q.db.QueryContext(ctx, getSectionsWithInstructorByTerm, term)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetSectionsWithInstructorByTermRow{}
	for rows.Next() {
		var i GetSectionsWithInstructorByTermRow
		if err := rows.Scan(
			&i.ID,
			&i.Term,
			&i.Crn,
			&i.Subject,
			&i.SubjectDescription,
			&i.CourseNumber,
			&i.Title,
			&i.CreditHoursLow,
			&i.Enrollment,
			&i.MaxEnrollment,
			&i.SeatsAvailable,
			&i.WaitCount,
			&i.IsOpen,
			&i.InstructionalMethod,
			&i.InstructorName,
			&i.InstructorEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubjectsWithDescriptionsByTerm = `-- name: GetSubjectsWithDescriptionsByTerm :many
SELECT DISTINCT subject, subject_description
FROM sections
WHERE term = ?
ORDER BY subject
`

type GetSubjectsWithDescriptionsByTermRow struct {
	Subject            string         `json:"subject"`
	SubjectDescription sql.NullString `json:"subject_description"`
}

func (q *Queries) GetSubjectsWithDescriptionsByTerm(ctx context.Context, term string) ([]*GetSubjectsWithDescriptionsByTermRow, error) {
	rows, err := q.db.QueryContext(ctx, getSubjectsWithDescriptionsByTerm, term)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetSubjectsWithDescriptionsByTermRow{}
	for rows.Next() {
		var i GetSubjectsWithDescriptionsByTermRow
		if err := rows.Scan(&i.Subject, &i.SubjectDescription); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTermByCode = `-- name: GetTermByCode :one
SELECT code, description, last_scraped_at FROM terms WHERE code = ?
`

func (q *Queries) GetTermByCode(ctx context.Context, code string) (*Term, error) {
	row := q.db.QueryRowContext(ctx, getTermByCode, code)
	var i Term
	err := row.Scan(&i.Code, &i.Description, &i.LastScrapedAt)
	return &i, err
}

const getTerms = `-- name: GetTerms :many
SELECT code, description, last_scraped_at FROM terms ORDER BY code DESC
`

func (q *Queries) GetTerms(ctx context.Context) ([]*Term, error) {
	rows, err := q.db.QueryContext(ctx, getTerms)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Term{}
	for rows.Next() {
		var i Term
		if err := rows.Scan(&i.Code, &i.Description, &i.LastScrapedAt); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTermsNeverScraped = `-- name: GetTermsNeverScraped :many
SELECT code, description, last_scraped_at FROM terms
WHERE last_scraped_at IS NULL ORDER BY code DESC
`

func (q *Queries) GetTermsNeverScraped(ctx context.Context) ([]*Term, error) {
	rows, err := q.db.QueryContext(ctx, getTermsNeverScraped)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Term{}
	for rows.Next() {
		var i Term
		if err := rows.Scan(&i.Code, &i.Description, &i.LastScrapedAt); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertInstructor = `-- name: InsertInstructor :exec
INSERT INTO instructors (section_id, banner_id, name, email, is_primary)
VALUES (?, ?, ?, ?, ?)
`

type InsertInstructorParams struct {
	SectionID int64          `json:"section_id"`
	BannerID  sql.NullString `json:"banner_id"`
	Name      string         `json:"name"`
	Email     sql.NullString `json:"email"`
	IsPrimary sql.NullInt64  `json:"is_primary"`
}

func (q *Queries) InsertInstructor(ctx context.Context, arg InsertInstructorParams) error {
	_, err := q.db.ExecContext(ctx, insertInstructor,
		arg.SectionID,
		arg.BannerID,
		arg.Name,
		arg.Email,
		arg.IsPrimary,
	)
	return err
}

const insertMeetingTime = `-- name: InsertMeetingTime :exec
INSERT INTO meeting_times (
    section_id, start_time, end_time, start_date, end_date,
    building, building_description, room,
    monday, tuesday, wednesday, thursday, friday, saturday, sunday,
    schedule_type, meeting_type, credit_hours, hours_per_week
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type InsertMeetingTimeParams struct {
	SectionID           int64           `json:"section_id"`
	StartTime           sql.NullString  `json:"start_time"`
	EndTime             sql.NullString  `json:"end_time"`
	StartDate           sql.NullString  `json:"start_date"`
	EndDate             sql.NullString  `json:"end_date"`
	Building            sql.NullString  `json:"building"`
	BuildingDescription sql.NullString  `json:"building_description"`
	Room                sql.NullString  `json:"room"`
	Monday              sql.NullInt64   `json:"monday"`
	Tuesday             sql.NullInt64   `json:"tuesday"`
	Wednesday           sql.NullInt64   `json:"wednesday"`
	Thursday            sql.NullInt64   `json:"thursday"`
	Friday              sql.NullInt64   `json:"friday"`
	Saturday            sql.NullInt64   `json:"saturday"`
	Sunday              sql.NullInt64   `json:"sunday"`
	ScheduleType        sql.NullString  `json:"schedule_type"`
	MeetingType         sql.NullString  `json:"meeting_type"`
	CreditHours         sql.NullFloat64 `json:"credit_hours"`
	HoursPerWeek        sql.NullFloat64 `json:"hours_per_week"`
}

func (q *Queries) InsertMeetingTime(ctx context.Context, arg InsertMeetingTimeParams) error {
	_, err := q.db.ExecContext(ctx, insertMeetingTime,
		arg.SectionID,
		arg.StartTime,
		arg.EndTime,
		arg.StartDate,
		arg.EndDate,
		arg.Building,
		arg.BuildingDescription,
		arg.Room,
		arg.Monday,
		arg.Tuesday,
		arg.Wednesday,
		arg.Thursday,
		arg.Friday,
		arg.Saturday,
		arg.Sunday,
		arg.ScheduleType,
		arg.MeetingType,
		arg.CreditHours,
		arg.HoursPerWeek,
	)
	return err
}

const insertSectionAttribute = `-- name: InsertSectionAttribute :exec
INSERT INTO section_attributes (section_id, code, description)
VALUES (?, ?, ?)
`

type InsertSectionAttributeParams struct {
	SectionID   int64          `json:"section_id"`
	Code        string         `json:"code"`
	Description sql.NullString `json:"description"`
}

func (q *Queries) InsertSectionAttribute(ctx context.Context, arg InsertSectionAttributeParams) error {
	_, err := q.db.ExecContext(ctx, insertSectionAttribute, arg.SectionID, arg.Code, arg.Description)
	return err
}

const logGeneration = `-- name: LogGeneration :exec
INSERT INTO generation_logs (term, courses_requested, schedules_generated, session_id)
VALUES (?, ?, ?, ?)
`

type LogGenerationParams struct {
	Term               sql.NullString `json:"term"`
	CoursesRequested   sql.NullString `json:"courses_requested"`
	SchedulesGenerated sql.NullInt64  `json:"schedules_generated"`
	SessionID          sql.NullString `json:"session_id"`
}

func (q *Queries) LogGeneration(ctx context.Context, arg LogGenerationParams) error {
	_, err := q.db.ExecContext(ctx, logGeneration,
		arg.Term,
		arg.CoursesRequested,
		arg.SchedulesGenerated,
		arg.SessionID,
	)
	return err
}

const logSearch = `-- name: LogSearch :exec
INSERT INTO search_logs (query, term, results_count, session_id)
VALUES (?, ?, ?, ?)
`

type LogSearchParams struct {
	Query        string         `json:"query"`
	Term         sql.NullString `json:"term"`
	ResultsCount sql.NullInt64  `json:"results_count"`
	SessionID    sql.NullString `json:"session_id"`
}

func (q *Queries) LogSearch(ctx context.Context, arg LogSearchParams) error {
	_, err := q.db.ExecContext(ctx, logSearch,
		arg.Query,
		arg.Term,
		arg.ResultsCount,
		arg.SessionID,
	)
	return err
}

const updateTermScrapedAt = `-- name: UpdateTermScrapedAt :exec
UPDATE terms SET last_scraped_at = CURRENT_TIMESTAMP WHERE code = ?
`

func (q *Queries) UpdateTermScrapedAt(ctx context.Context, code string) error {
	_, err := q.db.ExecContext(ctx, updateTermScrapedAt, code)
	return err
}

const upsertSection = `-- name: UpsertSection :one
INSERT INTO sections (
    term, crn, subject, subject_description, course_number, sequence_number,
    title, campus, schedule_type, instructional_method, instructional_method_desc,
    credit_hours_low, credit_hours_high, enrollment, max_enrollment, seats_available,
    wait_capacity, wait_count, is_open, updated_at
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
ON CONFLICT(term, crn) DO UPDATE SET
    subject = excluded.subject,
    subject_description = excluded.subject_description,
    course_number = excluded.course_number,
    sequence_number = excluded.sequence_number,
    title = excluded.title,
    campus = excluded.campus,
    schedule_type = excluded.schedule_type,
    instructional_method = excluded.instructional_method,
    instructional_method_desc = excluded.instructional_method_desc,
    credit_hours_low = excluded.credit_hours_low,
    credit_hours_high = excluded.credit_hours_high,
    enrollment = excluded.enrollment,
    max_enrollment = excluded.max_enrollment,
    seats_available = excluded.seats_available,
    wait_capacity = excluded.wait_capacity,
    wait_count = excluded.wait_count,
    is_open = excluded.is_open,
    updated_at = CURRENT_TIMESTAMP
RETURNING id
`

type UpsertSectionParams struct {
	Term                    string         `json:"term"`
	Crn                     string         `json:"crn"`
	Subject                 string         `json:"subject"`
	SubjectDescription      sql.NullString `json:"subject_description"`
	CourseNumber            string         `json:"course_number"`
	SequenceNumber          sql.NullString `json:"sequence_number"`
	Title                   string         `json:"title"`
	Campus                  sql.NullString `json:"campus"`
	ScheduleType            sql.NullString `json:"schedule_type"`
	InstructionalMethod     sql.NullString `json:"instructional_method"`
	InstructionalMethodDesc sql.NullString `json:"instructional_method_desc"`
	CreditHoursLow          sql.NullInt64  `json:"credit_hours_low"`
	CreditHoursHigh         sql.NullInt64  `json:"credit_hours_high"`
	Enrollment              sql.NullInt64  `json:"enrollment"`
	MaxEnrollment           sql.NullInt64  `json:"max_enrollment"`
	SeatsAvailable          sql.NullInt64  `json:"seats_available"`
	WaitCapacity            sql.NullInt64  `json:"wait_capacity"`
	WaitCount               sql.NullInt64  `json:"wait_count"`
	IsOpen                  sql.NullInt64  `json:"is_open"`
}

func (q *Queries) UpsertSection(ctx context.Context, arg UpsertSectionParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, upsertSection,
		arg.Term,
		arg.Crn,
		arg.Subject,
		arg.SubjectDescription,
		arg.CourseNumber,
		arg.SequenceNumber,
		arg.Title,
		arg.Campus,
		arg.ScheduleType,
		arg.InstructionalMethod,
		arg.InstructionalMethodDesc,
		arg.CreditHoursLow,
		arg.CreditHoursHigh,
		arg.Enrollment,
		arg.MaxEnrollment,
		arg.SeatsAvailable,
		arg.WaitCapacity,
		arg.WaitCount,
		arg.IsOpen,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const upsertTerm = `-- name: UpsertTerm :exec
INSERT INTO terms (code, description)
VALUES (?, ?)
ON CONFLICT(code) DO UPDATE SET description = excluded.description
`

type UpsertTermParams struct {
	Code        string `json:"code"`
	Description string `json:"description"`
}

func (q *Queries) UpsertTerm(ctx context.Context, arg UpsertTermParams) error {
	_, err := q.db.ExecContext(ctx, upsertTerm, arg.Code, arg.Description)
	return err
}
